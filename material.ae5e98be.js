parcelRequire=function(e,r,t,n){var i,o="function"==typeof parcelRequire&&parcelRequire,u="function"==typeof require&&require;function f(t,n){if(!r[t]){if(!e[t]){var i="function"==typeof parcelRequire&&parcelRequire;if(!n&&i)return i(t,!0);if(o)return o(t,!0);if(u&&"string"==typeof t)return u(t);var c=new Error("Cannot find module '"+t+"'");throw c.code="MODULE_NOT_FOUND",c}p.resolve=function(r){return e[t][1][r]||r},p.cache={};var l=r[t]=new f.Module(t);e[t][0].call(l.exports,p,l,l.exports,this)}return r[t].exports;function p(e){return f(p.resolve(e))}}f.isParcelRequire=!0,f.Module=function(e){this.id=e,this.bundle=f,this.exports={}},f.modules=e,f.cache=r,f.parent=o,f.register=function(r,t){e[r]=[function(e,r){r.exports=t},{}]};for(var c=0;c<t.length;c++)try{f(t[c])}catch(e){i||(i=e)}if(t.length){var l=f(t[t.length-1]);"object"==typeof exports&&"undefined"!=typeof module?module.exports=l:"function"==typeof define&&define.amd?define(function(){return l}):n&&(this[n]=l)}if(parcelRequire=f,i)throw i;return f}({"Mjy3":[function(require,module,exports) {
"use strict";window.SS=window.SS||{},SS.material=SS.material||{},SS.material.shaderMaterial=function(t,o){var r={pointLightPosition:{type:"v3",value:sunLight.position},map:{type:"t",value:t},normalMap:{type:"t",value:SS.util.heightToNormalMap(o,4)}};return new THREE.ShaderMaterial({uniforms:r,vertexShader:"\t\tvarying vec3 vNormal;\t\tvarying vec3 cameraVector;\t\tvarying vec3 vPosition;\t\tvarying vec2 vUv;\t\t\t\tvoid main() {\t\t\tvNormal = normal;\t\t\tvec4 vPosition4 = modelMatrix * vec4(position, 1.0);\t\t\tvPosition = vPosition4.xyz;\t\t\tcameraVector = cameraPosition - vPosition;\t\t\tvUv = uv;\t\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\t\t}\t",fragmentShader:"\t\tuniform vec3 pointLightPosition;\t\tuniform sampler2D map;\t\tuniform sampler2D normalMap;\t\t\t\tvarying vec3 vNormal;\t\tvarying vec3 vPosition;\t\tvarying vec3 cameraVector;\t\tvarying vec2 vUv;                mat4 rotationMatrix(vec3 axis, float angle) {            axis = normalize(axis);            float s = sin(angle);            float c = cos(angle);            float oc = 1.0 - c;                        return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,                        0.0,                                0.0,                                0.0,                                1.0);        }                vec3 bumpNormal(sampler2D normalMap, vec2 vUv) {            vec3 bumpedNormal = normalize(texture2D(normalMap, vUv).xyz * 2.0 - 1.0);                        vec3 y_axis = vec3(0,1,0);            float rot_angle = acos(dot(bumpedNormal,y_axis));            vec3 rot_axis = normalize(cross(bumpedNormal,y_axis));            return vec3(rotationMatrix(rot_axis, rot_angle) * vec4(vNormal, 1.0));        }        \t\tvoid main() {\t\t\tfloat PI = 3.14159265358979323846264;\t\t\tvec3 light = pointLightPosition - vPosition;\t\t\tvec3 cameraDir = normalize(cameraVector);            vec3 newNormal = bumpNormal(normalMap, vUv);\t\t\t\t\t\tlight = normalize(light);\t\t\t\t\t\tfloat lightAngle = max(0.0, dot(newNormal, light));\t\t\tfloat viewAngle = max(0.0, dot(vNormal, cameraDir));\t\t\tfloat adjustedLightAngle = min(0.6, lightAngle) / 0.6;\t\t\tfloat adjustedViewAngle = min(0.65, viewAngle) / 0.65;\t\t\tfloat invertedViewAngle = pow(acos(viewAngle), 3.0) * 0.4;\t\t\t\t\t\tfloat dProd = 0.0;\t\t\tdProd += 0.5 * lightAngle;\t\t\tdProd += 0.2 * lightAngle * (invertedViewAngle - 0.1);\t\t\tdProd += invertedViewAngle * 0.5 * (max(-0.35, dot(vNormal, light)) + 0.35);\t\t\tdProd *= 0.7 + pow(invertedViewAngle/(PI/2.0), 2.0);\t\t\t\t\t\tdProd *= 0.5;\t\t\tvec4 atmColor = vec4(0, dProd, dProd, 1.0);\t\t\t\t\t\tvec4 texelColor = texture2D(map, vUv) * min(asin(lightAngle), 1.0);\t\t\tgl_FragColor = texelColor + min(atmColor, 0.8);\t\t\t/*gl_FragColor = texture2D(map, vUv);*/\t\t}\t",transparent:!1})},SS.material.textureGeneratorMaterial=function(t){var o={index:{type:"i",value:t}};return new THREE.ShaderMaterial({uniforms:o,vertexShader:"\t\tvarying vec2 vUv;\t\t\t\tvoid main() {\t\t\tvUv = uv;\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\t\t}\t",fragmentShader:"\t\tvarying vec2 vUv;\n\t\tuniform int index;\n\t\t\t\tint mod(int x, int m) {\n\t\t\treturn int(mod(float(x), float(m)));\n\t\t}\n\t\t\t\tfloat random5(vec3 co) {\n\t\t\treturn fract(sin(dot(co.xyz ,vec3(12.9898,78.233,1.23456))) * 43758.5453);\n\t\t}\n\t\t\t\t\t\tfloat random4(float x, float y, float z) {\n\t\t\treturn random5(vec3(x, y, z));\n\t\t}\n\t\t\t\tfloat random4(int x, int y, int z) {\n\t\t\treturn random4(float(x), float(y), float(z));\n\t\t}\n\t\t\t\tfloat interpolation(float a, float b, float x) {\n\t\t\tfloat ft = x * 3.1415927;\n\t\t\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\t\treturn a*(1.0-f) + b*f;\n\t\t}\n\t\t\t\tfloat tricosine(vec3 coordFloat) {\n\t\t\tvec3 coord0 = vec3(floor(coordFloat.x), floor(coordFloat.y), floor(coordFloat.z));\n\t\t\tvec3 coord1 = vec3(coord0.x+1.0, coord0.y+1.0, coord0.z+1.0);\n\t\t\tfloat xd = (coordFloat.x - coord0.x)/max(1.0, (coord1.x-coord0.x));\n\t\t\tfloat yd = (coordFloat.y - coord0.y)/max(1.0, (coord1.y-coord0.y));\n\t\t\tfloat zd = (coordFloat.z - coord0.z)/max(1.0, (coord1.z-coord0.z));\n\t\t\tfloat c00 = interpolation(random4(coord0.x, coord0.y, coord0.z), random4(coord1.x, coord0.y, coord0.z), xd);\n\t\t\tfloat c10 = interpolation(random4(coord0.x, coord1.y, coord0.z), random4(coord1.x, coord1.y, coord0.z), xd);\n\t\t\tfloat c01 = interpolation(random4(coord0.x, coord0.y, coord1.z), random4(coord1.x, coord0.y, coord1.z), xd);\n\t\t\tfloat c11 = interpolation(random4(coord0.x, coord1.y, coord1.z), random4(coord1.x, coord1.y, coord1.z), xd);\n\t\t\tfloat c0 = interpolation(c00, c10, yd);\n\t\t\tfloat c1 = interpolation(c01, c11, yd);\n\t\t\tfloat c = interpolation(c0, c1, zd);\n\t\t\t\t\t\treturn c;\n\t\t}\n\t\t\t\tfloat nearestNeighbour(vec3 coordFloat) {\n\t\t\treturn random4(int(floor(coordFloat.x)), int(floor(coordFloat.y)), int(floor(coordFloat.z)));\n\t\t}\n\t\t\t\tfloat helper(float x, float y, float z, float resolution) {\n\t\t\tx = (x+1.0)/2.0*resolution;\n\t\t\ty = (y+1.0)/2.0*resolution;\n\t\t\tz = (z+1.0)/2.0*resolution;\n\t\t\t\n\t\t\tvec3 coordFloat = vec3(x, y, z);\n\t\t\tfloat interpolated = tricosine(coordFloat);\n\t\t\treturn interpolated*2.0 - 1.0;\n\t\t}\n\t\t\t\tvec3 scalarField(float x, float y, float z) {\n\t\t\tfloat resolution1 = 4.0;\n\t\t\tfloat resolution2 = 16.0;\n\t\t\tfloat resolution3 = 32.0;\n\t\t\tfloat resolution4 = 64.0;\n\t\t\tfloat resolution5 = 128.0;\n\t\t\tfloat resolutionMax = 256.0;\n\t\t\t\n\t\t\tvec3 coordFloat = vec3(0.0, 0.0, 0.0);\n\t\t\t\n\t\t\tfloat level1 = helper(x, y, z, resolution1);\n\t\t\tfloat level2 = helper(x, y, z, resolution2);\n\t\t\tfloat level3 = helper(x, y, z, resolution3);\n\t\t\tfloat level4 = helper(x, y, z, resolution4);\n\t\t\tfloat level5 = helper(x, y, z, resolution5);\n\t\t\tfloat levelMax = helper(x, y, z, resolutionMax);\n\t\t\t\n\t\t\tfloat c = 0.5;\n\t\t\tc *= 1.0 + level1*0.8;\n\t\t\tc *= 1.0 + level2*0.4;\n\t\t\tc *= 1.0 + level3*0.2;\n\t\t\tc *= 1.0 + level4*0.1;\n\t\t\tc *= 1.0 + level5*0.05;\n\t\t\tc *= 1.0 + levelMax*(0.025);\n\t\t\t\n\t\t\tif (c < 0.5) c *= 0.9;\n\t\t\t\n\t\t\tc = clamp(c, 0.0, 1.0);\n\t\t\t\n\t\t\treturn vec3(c, c, c);\n\t\t}\n\t\t\t\tvec3 getSphericalCoord(int index, float x, float y, float width) {\n\t\t\twidth /= 2.0;\n\t\t\tx -= width;\n\t\t\ty -= width;\n\t\t\tvec3 coord = vec3(0.0, 0.0, 0.0);\n\t\t\t\t\t\tif (index == 0) {coord.x=width; coord.y=-y; coord.z=-x;}\n\t\t\telse if (index == 1) {coord.x=-width; coord.y=-y; coord.z=x;}\n\t\t\telse if (index == 2) {coord.x=x; coord.y=width; coord.z=y;}\n\t\t\telse if (index == 3) {coord.x=x; coord.y=-width; coord.z=-y;}\n\t\t\telse if (index == 4) {coord.x=x; coord.y=-y; coord.z=width;}\n\t\t\telse if (index == 5) {coord.x=-x; coord.y=-y; coord.z=-width;}\n\t\t\t\t\t\treturn normalize(coord);\n\t\t}\t\t\t\tvoid main() {\n\t\t\tfloat x = vUv.x;\n\t\t\tfloat y = 1.0 - vUv.y;\n\t\t\tvec3 sphericalCoord = getSphericalCoord(index, x*1024.0, y*1024.0, 1024.0);\n\t\t\t\t\t\tvec3 color = scalarField(sphericalCoord.x, sphericalCoord.y, sphericalCoord.z);\n\t\t\t\t\t\tgl_FragColor = vec4(color.x, color.y, color.z, 1.0);\n\t\t}\t",transparent:!0,depthWrite:!1})};
},{}]},{},["Mjy3"], null)
//# sourceMappingURL=material.ae5e98be.js.map