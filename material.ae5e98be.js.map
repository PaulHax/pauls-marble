{"version":3,"sources":["planet/material.js"],"names":["window","SS","material","shaderMaterial","textureMap","bumpMap","vertexShader","uniforms","sunLight","position","util","heightToNormalMap","THREE","ShaderMaterial","fragmentShader","transparent","textureGeneratorMaterial","index","type","value","depthWrite"],"mappings":";AAAA,aAEAA,OAAOC,GAAKD,OAAOC,IAAM,GACzBA,GAAGC,SAAWD,GAAGC,UAAY,GAE7BD,GAAGC,SAASC,eAAiB,SAASC,EAAYC,GAC7CC,IA6EAC,EAAW,CACQ,mBAAA,CAAS,KAAA,KAAeC,MAAAA,SAASC,UAChD,IAAA,CAAS,KAAA,IAAcL,MAAAA,GACjB,UAAA,CAAS,KAAA,IAAcH,MAAAA,GAAGS,KAAKC,kBAAkBN,EAAS,KAGjE,OAAA,IAAIO,MAAMC,eAAe,CAC/BN,SAAUA,EACVD,aArFkB,0YAsFlBQ,eArEoB,+5EAsEpBC,aAAa,KAIfd,GAAGC,SAASc,yBAA2B,SAASC,GAC3CX,IA8HAC,EAAW,CACdU,MAAO,CAACC,KAAM,IAAKC,MAAOF,IAGpB,OAAA,IAAIL,MAAMC,eAAe,CAC/BN,SAAUA,EACVD,aApIkB,kJAqIlBQ,eA5HoB,ogIA6HpBC,aAAa,EACbK,YAAY","file":"material.ae5e98be.js","sourceRoot":"..\\src","sourcesContent":["\"use strict\";\n\nwindow.SS = window.SS || {};\nSS.material = SS.material || {};\n\nSS.material.shaderMaterial = function(textureMap, bumpMap) {\n\tvar vertexShader = \"\\\n\t\tvarying vec3 vNormal;\\\n\t\tvarying vec3 cameraVector;\\\n\t\tvarying vec3 vPosition;\\\n\t\tvarying vec2 vUv;\\\n\t\t\\\n\t\tvoid main() {\\\n\t\t\tvNormal = normal;\\\n\t\t\tvec4 vPosition4 = modelMatrix * vec4(position, 1.0);\\\n\t\t\tvPosition = vPosition4.xyz;\\\n\t\t\tcameraVector = cameraPosition - vPosition;\\\n\t\t\tvUv = uv;\\\n\t\t\t\\\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\\n\t\t}\\\n\t\";\n\t\n\tvar fragmentShader = \"\\\n\t\tuniform vec3 pointLightPosition;\\\n\t\tuniform sampler2D map;\\\n\t\tuniform sampler2D normalMap;\\\n\t\t\\\n\t\tvarying vec3 vNormal;\\\n\t\tvarying vec3 vPosition;\\\n\t\tvarying vec3 cameraVector;\\\n\t\tvarying vec2 vUv;\\\n        \\\n        mat4 rotationMatrix(vec3 axis, float angle) {\\\n            axis = normalize(axis);\\\n            float s = sin(angle);\\\n            float c = cos(angle);\\\n            float oc = 1.0 - c;\\\n            \\\n            return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\\n                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\\n                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\\n                        0.0,                                0.0,                                0.0,                                1.0);\\\n        }\\\n        \\\n        vec3 bumpNormal(sampler2D normalMap, vec2 vUv) {\\\n            vec3 bumpedNormal = normalize(texture2D(normalMap, vUv).xyz * 2.0 - 1.0);\\\n            \\\n            vec3 y_axis = vec3(0,1,0);\\\n            float rot_angle = acos(dot(bumpedNormal,y_axis));\\\n            vec3 rot_axis = normalize(cross(bumpedNormal,y_axis));\\\n            return vec3(rotationMatrix(rot_axis, rot_angle) * vec4(vNormal, 1.0));\\\n        }\\\n        \\\n\t\tvoid main() {\\\n\t\t\tfloat PI = 3.14159265358979323846264;\\\n\t\t\tvec3 light = pointLightPosition - vPosition;\\\n\t\t\tvec3 cameraDir = normalize(cameraVector);\\\n            vec3 newNormal = bumpNormal(normalMap, vUv);\\\n\t\t\t\\\n\t\t\tlight = normalize(light);\\\n\t\t\t\\\n\t\t\tfloat lightAngle = max(0.0, dot(newNormal, light));\\\n\t\t\tfloat viewAngle = max(0.0, dot(vNormal, cameraDir));\\\n\t\t\tfloat adjustedLightAngle = min(0.6, lightAngle) / 0.6;\\\n\t\t\tfloat adjustedViewAngle = min(0.65, viewAngle) / 0.65;\\\n\t\t\tfloat invertedViewAngle = pow(acos(viewAngle), 3.0) * 0.4;\\\n\t\t\t\\\n\t\t\tfloat dProd = 0.0;\\\n\t\t\tdProd += 0.5 * lightAngle;\\\n\t\t\tdProd += 0.2 * lightAngle * (invertedViewAngle - 0.1);\\\n\t\t\tdProd += invertedViewAngle * 0.5 * (max(-0.35, dot(vNormal, light)) + 0.35);\\\n\t\t\tdProd *= 0.7 + pow(invertedViewAngle/(PI/2.0), 2.0);\\\n\t\t\t\\\n\t\t\tdProd *= 0.5;\\\n\t\t\tvec4 atmColor = vec4(0, dProd, dProd, 1.0);\\\n\t\t\t\\\n\t\t\tvec4 texelColor = texture2D(map, vUv) * min(asin(lightAngle), 1.0);\\\n\t\t\tgl_FragColor = texelColor + min(atmColor, 0.8);\\\n\t\t\t/*gl_FragColor = texture2D(map, vUv);*/\\\n\t\t}\\\n\t\";\n\t\n\tvar uniforms = {\n\t\t\"pointLightPosition\": {\"type\": \"v3\", \"value\": sunLight.position},\n\t\t\"map\": {\"type\": \"t\", \"value\": textureMap},\n\t\t\"normalMap\": {\"type\": \"t\", \"value\": SS.util.heightToNormalMap(bumpMap, 4.0)}\n\t};\n\n\treturn new THREE.ShaderMaterial({\n\t\tuniforms: uniforms,\n\t\tvertexShader: vertexShader,\n\t\tfragmentShader: fragmentShader,\n\t\ttransparent: false\n\t});\n}\n\nSS.material.textureGeneratorMaterial = function(index) {\n\tvar vertexShader = \"\\\n\t\tvarying vec2 vUv;\\\n\t\t\\\n\t\tvoid main() {\\\n\t\t\tvUv = uv;\\\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\n\t\t}\\\n\t\";\n\t\n\tvar fragmentShader = \"\\\n\t\tvarying vec2 vUv;\\n\\\n\t\tuniform int index;\\n\\\n\t\t\\\n\t\tint mod(int x, int m) {\\n\\\n\t\t\treturn int(mod(float(x), float(m)));\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat random5(vec3 co) {\\n\\\n\t\t\treturn fract(sin(dot(co.xyz ,vec3(12.9898,78.233,1.23456))) * 43758.5453);\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\t\\\n\t\tfloat random4(float x, float y, float z) {\\n\\\n\t\t\treturn random5(vec3(x, y, z));\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat random4(int x, int y, int z) {\\n\\\n\t\t\treturn random4(float(x), float(y), float(z));\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat interpolation(float a, float b, float x) {\\n\\\n\t\t\tfloat ft = x * 3.1415927;\\n\\\n\t\t\tfloat f = (1.0 - cos(ft)) * 0.5;\\n\\\n\t\t\treturn a*(1.0-f) + b*f;\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat tricosine(vec3 coordFloat) {\\n\\\n\t\t\tvec3 coord0 = vec3(floor(coordFloat.x), floor(coordFloat.y), floor(coordFloat.z));\\n\\\n\t\t\tvec3 coord1 = vec3(coord0.x+1.0, coord0.y+1.0, coord0.z+1.0);\\n\\\n\t\t\tfloat xd = (coordFloat.x - coord0.x)/max(1.0, (coord1.x-coord0.x));\\n\\\n\t\t\tfloat yd = (coordFloat.y - coord0.y)/max(1.0, (coord1.y-coord0.y));\\n\\\n\t\t\tfloat zd = (coordFloat.z - coord0.z)/max(1.0, (coord1.z-coord0.z));\\n\\\n\t\t\tfloat c00 = interpolation(random4(coord0.x, coord0.y, coord0.z), random4(coord1.x, coord0.y, coord0.z), xd);\\n\\\n\t\t\tfloat c10 = interpolation(random4(coord0.x, coord1.y, coord0.z), random4(coord1.x, coord1.y, coord0.z), xd);\\n\\\n\t\t\tfloat c01 = interpolation(random4(coord0.x, coord0.y, coord1.z), random4(coord1.x, coord0.y, coord1.z), xd);\\n\\\n\t\t\tfloat c11 = interpolation(random4(coord0.x, coord1.y, coord1.z), random4(coord1.x, coord1.y, coord1.z), xd);\\n\\\n\t\t\tfloat c0 = interpolation(c00, c10, yd);\\n\\\n\t\t\tfloat c1 = interpolation(c01, c11, yd);\\n\\\n\t\t\tfloat c = interpolation(c0, c1, zd);\\n\\\n\t\t\t\\\n\t\t\treturn c;\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat nearestNeighbour(vec3 coordFloat) {\\n\\\n\t\t\treturn random4(int(floor(coordFloat.x)), int(floor(coordFloat.y)), int(floor(coordFloat.z)));\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tfloat helper(float x, float y, float z, float resolution) {\\n\\\n\t\t\tx = (x+1.0)/2.0*resolution;\\n\\\n\t\t\ty = (y+1.0)/2.0*resolution;\\n\\\n\t\t\tz = (z+1.0)/2.0*resolution;\\n\\\n\t\t\t\\n\\\n\t\t\tvec3 coordFloat = vec3(x, y, z);\\n\\\n\t\t\tfloat interpolated = tricosine(coordFloat);\\n\\\n\t\t\treturn interpolated*2.0 - 1.0;\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tvec3 scalarField(float x, float y, float z) {\\n\\\n\t\t\tfloat resolution1 = 4.0;\\n\\\n\t\t\tfloat resolution2 = 16.0;\\n\\\n\t\t\tfloat resolution3 = 32.0;\\n\\\n\t\t\tfloat resolution4 = 64.0;\\n\\\n\t\t\tfloat resolution5 = 128.0;\\n\\\n\t\t\tfloat resolutionMax = 256.0;\\n\\\n\t\t\t\\n\\\n\t\t\tvec3 coordFloat = vec3(0.0, 0.0, 0.0);\\n\\\n\t\t\t\\n\\\n\t\t\tfloat level1 = helper(x, y, z, resolution1);\\n\\\n\t\t\tfloat level2 = helper(x, y, z, resolution2);\\n\\\n\t\t\tfloat level3 = helper(x, y, z, resolution3);\\n\\\n\t\t\tfloat level4 = helper(x, y, z, resolution4);\\n\\\n\t\t\tfloat level5 = helper(x, y, z, resolution5);\\n\\\n\t\t\tfloat levelMax = helper(x, y, z, resolutionMax);\\n\\\n\t\t\t\\n\\\n\t\t\tfloat c = 0.5;\\n\\\n\t\t\tc *= 1.0 + level1*0.8;\\n\\\n\t\t\tc *= 1.0 + level2*0.4;\\n\\\n\t\t\tc *= 1.0 + level3*0.2;\\n\\\n\t\t\tc *= 1.0 + level4*0.1;\\n\\\n\t\t\tc *= 1.0 + level5*0.05;\\n\\\n\t\t\tc *= 1.0 + levelMax*(0.025);\\n\\\n\t\t\t\\n\\\n\t\t\tif (c < 0.5) c *= 0.9;\\n\\\n\t\t\t\\n\\\n\t\t\tc = clamp(c, 0.0, 1.0);\\n\\\n\t\t\t\\n\\\n\t\t\treturn vec3(c, c, c);\\n\\\n\t\t}\\n\\\n\t\t\\\n\t\tvec3 getSphericalCoord(int index, float x, float y, float width) {\\n\\\n\t\t\twidth /= 2.0;\\n\\\n\t\t\tx -= width;\\n\\\n\t\t\ty -= width;\\n\\\n\t\t\tvec3 coord = vec3(0.0, 0.0, 0.0);\\n\\\n\t\t\t\\\n\t\t\tif (index == 0) {coord.x=width; coord.y=-y; coord.z=-x;}\\n\\\n\t\t\telse if (index == 1) {coord.x=-width; coord.y=-y; coord.z=x;}\\n\\\n\t\t\telse if (index == 2) {coord.x=x; coord.y=width; coord.z=y;}\\n\\\n\t\t\telse if (index == 3) {coord.x=x; coord.y=-width; coord.z=-y;}\\n\\\n\t\t\telse if (index == 4) {coord.x=x; coord.y=-y; coord.z=width;}\\n\\\n\t\t\telse if (index == 5) {coord.x=-x; coord.y=-y; coord.z=-width;}\\n\\\n\t\t\t\\\n\t\t\treturn normalize(coord);\\n\\\n\t\t}\\\n\t\t\\\n\t\tvoid main() {\\n\\\n\t\t\tfloat x = vUv.x;\\n\\\n\t\t\tfloat y = 1.0 - vUv.y;\\n\\\n\t\t\tvec3 sphericalCoord = getSphericalCoord(index, x*1024.0, y*1024.0, 1024.0);\\n\\\n\t\t\t\\\n\t\t\tvec3 color = scalarField(sphericalCoord.x, sphericalCoord.y, sphericalCoord.z);\\n\\\n\t\t\t\\\n\t\t\tgl_FragColor = vec4(color.x, color.y, color.z, 1.0);\\n\\\n\t\t}\\\n\t\";\n\t\n\tvar uniforms = {\n\t\tindex: {type: \"i\", value: index}\n\t};\n\n\treturn new THREE.ShaderMaterial({\n\t\tuniforms: uniforms,\n\t\tvertexShader: vertexShader,\n\t\tfragmentShader: fragmentShader,\n\t\ttransparent: true,\n\t\tdepthWrite: false\n\t});\n}\n\n"]}